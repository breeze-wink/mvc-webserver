## egrep 几个常用的案例，便于理解

```bash
//1. 匹配身份证: 
    egrep -n '^[0-9]{17}[0-9X]$' filename  // 如果要在同一行头尾加上^和$

//2. 匹配账号是否合法（字母开头，允许5-16字节，允许字母数字下划线）:
    egrep -n '^[a-zA-Z]\w{4,15}$' filename

//3. 匹配密码是否合法（字母开头，长度在8-18字节之间，只能包含字母，数字，下划线）：
    egrep -n '^[a-zA-Z]\w{7,17}$' filename

//4. 匹配日期 ex. 2022-11-23
    egrep -n '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' filename

```
## sed 示范
__(注意开始和末尾有没有 / )__

加上 __-e__ 参数可以同时执行多个命令
加上 __-n__ 参数可以只打印修改的行数
加上 __-r__ 参数使用扩展正则比如 m __,__ n
加上 __-i__ 参数直接修改文本，不加的话只打印修改后的内容，不修改

- (^.\*)表示行首开始一直往后直到分割符号例如_，(.*$)表示符号开始一直到行尾

__/ /__ 中可以使用正则表达式，一般不用。

```bash

2.sed -i '/pattern/i\insertPattern' fileName 表示在匹配pattern的前面插入一行 insertPattern
3.sed -i '/pattern/a\insertPattern' fileName 表示在匹配pattern的后面插入一行
4.sed -i '/pattern/d' fileName 删除
5.sed -i 's/pattern/newPattern/' fileName 替换每行第一个匹配 （如果要在新pa表示替换内容用&）
  sed -i 's/pattern/newPattern/g' fileName 替换每行所有匹配
  sed -r '18,21s#(^.*)_(.*$)#\2_\1#' num.txt s配合()进行操作，调换顺序, # 和 /是一样的
  sed -r -i '23,26s/(^.*)/\#\1/' num.txt 范围添加符号  


6.sed -r '1,3c "hello world"' fileName 表示将1-3行直接换成hello world（上面的s参数替换部分内容）
7.sed -n '/pattern/p' fileName 输出匹配的行
//8.最前面假如数字例如 sed -i '5s/...' (only 5)  或 sed -i '5,10s/...'(from 5 to 10) 表示只对指定行号进行操作。
```

- 常用的日志文件查询
``` bash
sed -n '/2003-10-10 10:10:00/,/2003-10-10 10:10:10/p' fileName
```
- 删除也可以用类似操作
```bash
sed -r '/2003-10-10 10:10:00/,/2003-10-10 10:10:10/d' fileName
如果逗号右边写 $ 表示删除到最后一行
```
- 同上的范围替换
```bash
sed -r '/2003-10-10 10:10:00/,/2003-10-10 10:10:10/c "hello world' fileName
```

## awk

- awk命令的执行过程
(1)BEGIN指令，
(2)读取每一行，判断该行是否满足条件，如果满足条件，进行什么操作。（按这个逻辑理解就好）
(3)END指令，

- -F设定查询分隔符，-vOFS= 设定输出分隔符
```bash
// 参数F后紧跟着分隔符，NR是判定的行数，$n 表示第n个模块，$0 表示全部，$NF 表示最后一个模块，NR不写默认对全部行操作
awk -F: 'BEGIN{print "this is BEGIN"}NR==1{print $1}NR==4{print $2,$3}END{print "this is END"}' fileName
// 第一行到第五行可以用 NR==1,NR==5 或者 NR>=1&&NR<=5
```

```bash
// 可以用//像sed中一样表达范围
awk -F: '/101010/,/202020/{operation}' fileName
```

**重中之重**
```bash
// 对指定列进行正则判定，再对满足条件的元素所在的行进行操作。
awk -F: '$4~/^s/{operation}' fileName
// 不支持{m,n}，需要具体化 用 ||分隔
awk -F: '($3~/^[0-9][0-9]$/||$3~/^[0-9]$/){print $1,$3}' passwd
```

- 如果想先筛选行再筛选列中的行，可以将sed 和 awk 联合，使用管道，如下
```bash
sed -nr '/101010/,/202020/p' passwd | awk -F: '$3~/^[0-9][0-9]$/{print $1, $3}'
```

**常见用例**
- 获取文件行数
```bash
awk '{sum++}END{print sum}' fileName
```

- 统计某一列的和

```bash
awk '{sum+=$2}END{print sum}' fileName
```